---
title: "[CS] Operating System - 컴퓨터 시스템의 구성2"
description: CS 운영체제 학습
coverImage: https://firebasestorage.googleapis.com/v0/b/kingsjw7-8d984.appspot.com/o/tech%2Foperating-system%2Foperating-system.jpeg?alt=media&token=e1e85b52-47ab-4d59-bd19-4d448a5e46c3
writer: kingsjw7
date: 2023-09-20
---

# [CS] Operating System - 컴퓨터 시스템의 구성2

> Software Engineer에게 필요한 운영체제 기초지식을 학습하자  
> 이 글은 [Operating System Concepts](https://product.kyobobook.co.kr/detail/S000001868743)을 기반으로 작성되었다.

## 학습 목표

- 컴퓨터 시스템에 구성 중 저장장치, 입출력 구조에 대해 이해한다.

## 저장장치 구조(Storage Structure)

CPU는 메모리에서만 명령을 적재할 수 있으므로 실행하려면 프로그램을 먼저 메모리에 적재해야 한다.  
범용 컴퓨터는 프로그램 대부분을 메인 메모리(**random accsess memory**, 또는 **RAM**이라 불린다)라 불리는 재기록 가능한 메모리에서 가져온다.  
메인 메모리는 **dynamic random-access memory** (**DRAM**)라 불리는 반도체 기술로 구현된다.

컴퓨터는 다른 형태의 메모리도 사용한다.  
예를 들어, 컴퓨터 전원을 켤 때 가장 먼저 실행되는 프로그램은 **부트스트랩 프로그램**이며 운영체제를 적재한다.  
RAM은 **휘발성**(전원이 꺼지거나 손실될 때 내용이 손실됨)이므로 부트스트랩 프로그램을 유지하는 용도로 사용할 수 없다.  
대신 이 목적과 다른 목적으로, 컴퓨터는 전기적으로 소거 가능한 프로그램 가능 읽기 전용 메모리(EEPROM) 및 기타 형태의 **펌웨어**(쓰기 작업이 자주 발생하지 않고 비활성인 저장장치)를 사용한다.  
EEPROM은 변경할 수는 있지만 자주 변경할 수는 없다.  
또한 속도가 느리므로 주로 사용되지 않는 정적 프로그램과 데이터가 포함되어 있다.  
예를 들어, iPhone은 EEPROM을 사용하여 장치의 일련 번호 및 하드웨어 정보를 저장한다.

모든 형태의 메모리는 바이트의 배열을 제공한다.  
각 바이트는 자신의 주소를 가지고 있다.  
상호 작용은 특정 메모리 주소들에 대한 일련의 적재(load), 또는 저장(store) 명령을 통하여 이루어진다.  
적재 명령은 메인 메모리로부터 CPU 내부의 레지스터로 한 바이트 또는 한 워드를 옮기는 것이다.  
반대로 저장 명령은 레지스터의 내용을 메인 메모리로 옮긴다.  
명시적인 적재, 저장 명령 외에, CPU는 프로그램 카운터에 저장된 위치부터 실행하기 위해 메인 메모리에서 명령을 자동으로 적재한다.

**폰 노이만 구조 시스템**에서 실행되는 전형적인 명령 - 실행 사이클은 먼저 메모리로부터 명령을 인출해, 그 명령을 **명령 레지스터**(instruction register)에 저장한다.  
이어서 명령을 해독하고, 이는 메모리로부터 피연산자를 인출하여 내부 레지스터에 저장하도록 유발할 수 있다.  
메모리 장치는 단지 일련의 메모리 주소만을 인식한다는 사실에 유의하라.  
메모리는 이들 주소[명령 카운터(instruction counter), 색인(indexing), 간접 주소(indi-rection),리터럴 주소(literal addresses) 등]가 어떻게 생성되었는지 알지 못하며, 그 것이 무엇인지(명령인지 데이터인지) 알지 못한다.  
그러므로 우리는 메모리 주소가 프로그램에 의해 어떻게 생성되었는지 무시 할 수 있다.  
우리는 단지 실행 중인 프로그램에 의해 생성된 일련의 메모리 주소에만 흥미가 있다.

이상적으로는, 프로그램과 데이터가 메인 메모리에 영구히 존재하기를 원한다.  
그러나 이는 대부분의 시스템에서 두 가지 이유로는 불가능하다.

1. 메인 메모리는 모든 필요한 프로그램과 데이터를 영구히 저장하기에는 너무 작다.
2. 메인 메모리는 이미 언급한 것처럼 전원이 공급되지 않으면 그 내용을 잃어버리는 휘발성 저장장치이다.

그러므로 대부분의 컴퓨터 시스템은 메인 메모리의 확장으로 **보조저장장치**를 제공한다.  
보조저장장치의 주요 요건은 대량의 데이터를 영구히 보존할 수 있어야 한다는 점이다.

가장 일반적인 보조저장장치는 **하드 디스크 드라이**(**HDD**)와 **비활성 메모리**(**NVM**) **장치**로, 프로그램과 데이터 모두를 위한 정소를 제공한다.  
대부분의 프로그램(시스템 및 응용 프로그램)은 메모리에 적재될 때까지 보조저장장치에 저장된다.  
그런 후 많은 프로그램이 보조저장장치를 처리 소스 및 대상으로 모두 사용한다.  
보조저장장치도 메인 메모리보다 훨씬 느리다.  
따라서 11장에서 논의할 것처럼, 2차 저장장치의 올바른 관리는 컴퓨터 시스템에서 가장 중요하다.

그러나 더 큰 의미에서 레지스터, 메인 메모리 및 보조저장장치로 구성된 저장장치 구조는 가능한 많은 저장장치 시스템 설계 중 하나일 뿐이다.  
다른 가능한 구성요소로는 캐시 메모리, CD-ROM, 또는 Blu-ray, 자기 테이프 등이 있다.  
다른 장치에 저장된 자료의 백업 사본을 저장하기 위해 특수 목적으로만 사용하기에 매우 느리고 충분히 큰 장치를 **3차 저장장치**라고 한다.  
각 저장장치 시스템은 데이터를 저장하고 나중에 검색될 때까지 해당 데이터를 유지하는 기본 기능을 제공한다.  
다양한 저장장치 시스템 간의 주요 차이점은 속도, 크기 및 휘발성에 있다.

다양한 저장장치 시스템은 저장 용량 및 엑세스 시간에 따라 계층 구조로 구성될 수 있다(그림 1.6).  
일반적으로 크기와 속도 사이에는 상충하는 측면이 있어서 메모리가 작고 빠를수로 CPU에 더 가깝다.  
그림에서 볼 수 있듯이 속도와 용량의 차이 외에도 다양한 저장장치 시스템은 휘발성 또는 비휘발성이다.  
앞에서 언급했듯이 휘발성 저장장치는 장치의 전원이 제거될 때 내용을 잃어버리므로 안전하게 보관하기 위해 데이터를 비휘발성 저장장치에 기록해야한다.

그림에서 취상위 4단계 메모리는 반도체 기반 전자회로로 구성된 **반도체 메모리**를 사용하여 구성된다.  
네 번째 수준의 NVM 장치에는 여러 가지 변형이 있지만 일반적으로 하드 디스크보다 빠르다.  
NVM 장치의 가장 일반적인 형태는 스마트폰 및 태블릿과 같은 모바일 장치에서 널리 사용되는 플래시 메모리이다.  
점차 랩톱, 데스크톱과 서버에서의 장기 저장에도 플래시 메모리가 사용되고 있다.

저장장치는 운영체제 구조에서 중요한 역할을 하기 때문에 교재에서 자주 참조할 것이다.  
일반적으로 다음 용어를 사용할 것이다.

- 휠발성 저장장치는 단순히 **메모리**라고 할 것이다. 특정 유형의 저장치(예: 레지스터)를 강조해야하는 경우 명시적으로 표현할 것이다.
- 비휘발성 저장장치는 전원이 꺼졌을 때 내용을 유지한다. 이를 **NVS**라고 한다. 대부분의 경우 NVS는 보조저장장치를 가리킨다. 이 유형의 저장장치는 다음 두 가지 유형으로 분류될 수 있다.

  - **기계적**. 이러한 저장장치 시스템의 몇 가지 예는 HDD, 광 디스크, 홀로그램 저장장치 및 자기 테이프이다. 특정 유형의 기계식 저장장치(예: 자기 테이프)를 강조해야 하는 경우 명시적으로 그 용어를 사용할 것이다.
  - **전기적**. 이러한 저장장치 시스템의 몇 가지 예는 플래시 메모리, GRAM, NRAM 및 SSD이다. 전기적 저장장치를 **NVM**으로 언급될 것이다. 특정 유형의 전기적 저장장치(예: SSD)를 강조해야 하는 경우 명시적으로 그 용어를 사용할 것이다.

  기계적 저장장치는 일반적으로 전기적 저장장치보다 용량이 크고 바이트당 비용이 저렴하다.  
  반대로, 전기적 저장장치는 일반적으로 기계적 저장장치보다 비싸고 용량이 적으며 빠르다.

완전한 저장장치 시스템의 설계는 방금 논의한 모든 요소의 균형을 맞추어야 한다.  
가능한 한 많은 저렴한 비휘발성 저장장치를 제공하는 동시에 필요한 만큼만 비싼 메모리를 사용해야 한다.  
캐시는 두 구성요소 간에 액세스 시간이나 전송 속도의 차이가 큰 경우 성능을 향상하기 위해 설치할 수 있다.

<img src="https://firebasestorage.googleapis.com/v0/b/kingsjw7-8d984.appspot.com/o/tech%2Foperating-system%2Fstore-layer-structure.jpeg?alt=media&token=bfea4d9d-bde7-4272-b94c-ca81f02563de" width="500px" alt="저장장치 계층 구조">

### 저장장치 정의와 표기

컴퓨터 저장장치의 기본단위는 비트이다.  
한 비트는 0과 1 두 값 중 하나를 가진다.  
컴퓨터의 모든 다른 저장장치는 비트의 집합을 기반으로 한다.  
비트의 길이가 충분히 긴 경우 컴퓨터는 놀랍게도 다양한 것들을 표햔할 수 있다.  
몇 개 예를 든다면 숫자, 글자, 영상, 영화, 소리, 문서 그리고 프로그램 등이다.  
한 **바이트**는 8비트이고 대부분의 컴퓨터에서는 가장 작은 편리한 저장 단위이다.  
예를 들면 대부분의 컴퓨터들은 하나의 비트를 이동하는 명령어는 제공하지 않지만 한 바이트를 이동하는 명령어는 제공한다.  
약간 덜 알려진 용어가 **워드**이다.  
워드는 그 컴퓨터 구조의 본연의 테이터 단위이다.  
한 워드는 하나 이상의 바이트로 구성된다.  
예를 들면 64비트 레지스터들과 64비트, 메모리 주소지정을 가지는 컴퓨터는 전형적으로 64비트(8바이트) 워드를 가진다.  
컴퓨터는 많은 연산을 한 번에 한 바이트 단위가 아니라 본연의 워드 단위로 실행한다.

컴퓨터 저장장치는 대부분의 컴퓨터 처리량과 마찬가지로 바이트 단위 및 바이트의 집합 단위로 측정되며 조작된다.  
1**킬로바이트** 또는 **KB**는 1,024바이트이고, 1**메가바이트** 또는 **MB**는 1,024^2바이트, 1**기가바이트** 또는 **GB**는 1,024^3바이트, 1**테라바이트** 또는 **TB**는 1,024^4바이트, 1**페타바이트** 또는 **PB**는 1,024^5바이트이다.  
컴퓨터 제조업체는 이들 숫자를 반올림하여 1메가바이트를 백만 바이트, 1기가바이트를 십억 바이트라 말한다.  
네트워킹 수치는 이러한 일반 규칙에 대한 예외로 비트 단위로 표현된다.  
왜냐하면 네트워크는 데이터를 한 번에 1비트씩 이동하기 때문이다.

## 입출력 구조(I/O Structure)

운영체제 코드의 상당 부분은 시스템의 안정성과 성능에 대한 중요성과 장치의 다양한 특성으로 인해 I/O 관리에 할애된다.

시스템은 범용 버스를 통해 데이터를 교환하는 여러 장치로 구성된 범용 컴퓨터라는 점을 상기하라.  
인터럽트 구동 I/O의 형태는 소량의 데이터를 이동하는 데는 좋지만 NVS I/O와 같은 대량 데이터 이동에 사용 될 때 높은 오버헤드를 유발할 수 있다.  
이 문제를 해결하기 위해 **직접 메모리 액세스** (**DMA**)가 사용된다.  
장치에 대한 버퍼 및 포인터, 입출력 카운트를 세팅한 후 장치 제어기는 CPU의 개입 없이 메모리로부터 자신의 버퍼 장치로 또는 버퍼로부터 메모리로 데이터 블록 전체를 전송한다.  
속도가 느린 장치처럼 한 바이트마다 인터럽트가 발생하는 것이 아니라 블록 전송이 완료될 때마다 인터럽트가 발생한다.  
장치 컨트롤러가 전송 작업을 수행하고 있는 동안 CPU는 다른 작업을 수행할 수 있다.

몇몇 고가의 시스템은 버스 대신에 스위치 구조를 사용한다.  
이러한 시스템에서는 공유 버스를 사용하기 위한 사이클을 경쟁하지 않고 다수의 구성요소가 다른 구성요소들과 동시에 통신하는 것이 가능하다.  
이 경우 DMA의 사용은 더욱 효과적이다.  
그림 1.7은 컴퓨터 시스템의 구성요소 간의 상호 작용을 보여준다.

<img src="https://firebasestorage.googleapis.com/v0/b/kingsjw7-8d984.appspot.com/o/tech%2Foperating-system%2FhowModernComputersWork.jpeg?alt=media&token=7a410ce0-49f5-4489-ba74-7f80db3c5c0f" width="500px" alt="현대 컴퓨터 작동 방식">
